import numpy as np

def conv_out_size(input_size: [int], stride: [int], kernel: [int]) -> [int] : ...
def conv_in_size(output_size: [int], stride: [int], kernel: [int]) -> [int] : ...
def conv_in_range_with_custom_size(output_pos: [int], output_size: [int], stride: [int], kernel: [int]) -> ([int], [int]) : ...
def conv_in_range(output_pos: [int], stride: [int], kernel: [int]) -> ([int], [int]) : ...
def conv_out_range(input_pos: [int], stride: [int], kernel: [int]) -> ([int], [int]) : ...
def conv_out_range_clipped_both_sides(input_pos: [int], stride: [int], kernel: [int], max_bounds: [int]) -> ([int], [int]) : ...
def conv_in_range_begin(output_pos: [int], stride: [int]) -> [int] : ...
def conv_stride(input_size: [int], output_size: [int], kernel: [int]) -> [int] :
    """
    :param input_size: [x,y,...]
    :param output_size: same size as input_size
    :param kernel: same size as input_size
    :return: same size as input_size
    """
def conv_compose_array(strides: [(int, int, int)], kernels: [(int, int, int)]) -> ((int,int,int),(int,int,int)) :
    """
    :param strides: [(int,int,int?)]
    :param kernels: [(int,int,int?)]
    :return stride:(int,int,int), kernel:(int,int,int)
    """
def conv_compose(stride1: [int], kernel1: [int], stride2: [int], kernel2: [int]) -> ((int,int,int),(int,int,int)) : ...
def conv_compose_weights(stride1: [int], weights1: 'np.ndarray[np.float32]', bias1: 'np.ndarray[np.float32]',
                         stride2: [int], weights2: 'np.ndarray[np.float32]', bias2: 'np.ndarray[np.float32]') -> ([int], 'np.ndarray[np.float32]', 'np.ndarray[np.float32]') : ...

class ConvShape:
    def __init__(self, output: (int,int), kernel: (int,int), stride: (int,int), in_channels: int, out_channels: int): ...
    def u_shape(self) -> (int, int, int, int) :
        """
        [out_height, out_width, out_channels, out_channels]
        """
    def minicolumn_u_shape(self) -> (int, int) : ...
    def w_shape(self) -> (int, int, int, int, int, int) : ...
    def out_shape(self) -> (int, int, int) : ...
    def in_shape(self) -> (int, int, int) : ...
    def kernel(self) -> (int, int) : ...
    def kernel_height(self) -> int : ...
    def kernel_width(self) -> int : ...
    def rand_dense_input(self, cardinality: int) -> [bool] : ...
    def rand_dense_output(self, cardinality: int) -> [bool] : ...
    def rand_sparse_input(self, cardinality: int) -> [int] : ...
    def rand_sparse_output(self, cardinality: int) -> [int] : ...
    def stride(self) -> (int, int) : ...
    def kernel_column_shape(self) -> (int, int, int) : ...
    def minicolumn_w_shape(self) -> (int, int, int, int) : ...
    def kernel_column_area(self) -> int : ...
    def kernel_column_volume(self) -> int : ...
    def in_grid(self) -> (int, int) : ...
    def out_grid(self) -> (int, int) : ...
    def out_width(self) -> int : ...
    def out_height(self) -> int : ...
    def out_channels(self) -> int : ...
    def in_width(self) -> int : ...
    def in_height(self) -> int : ...
    def in_channels(self) -> int : ...
    def out_area(self) -> int : ...
    def in_area(self) -> int : ...
    def out_volume(self) -> int : ...
    def in_volume(self) -> int : ...
    def kernel_offset(self, output_pos: (int, int, int)) -> (int, int) : ...
    def pos_within_kernel(self, input_pos: (int, int, int), output_pos: (int, int, int)) -> (int, int, int) : ...
    def idx_within_kernel(self, input_pos: (int, int, int), output_pos: (int, int, int)) -> int : ...
    def receptive_field_shape(self) -> (int, int, int, int, int, int) : ...
    def minicolumn_receptive_field_shape(self) -> (int, int, int, int) : ...
    def in_range(self, output_column_pos: (int, int)) -> ((int, int), (int, int)) : ...
    def out_range(self, input_pos: (int, int)) -> ((int, int), (int, int)) : ...
    def normalize_kernel_columns(self, conv_tensor: 'np.ndarray[np.float32]', norm: int) : ...
    def sparse_kernel_column_input_subset(self, indices: 'np.ndarray[np.int32]', output_pos:(int,int)) -> 'np.ndarray[np.int32]' : ...
    def sparse_kernel_column_input_subset_reindexed(self, indices: 'np.ndarray[np.int32]', output_pos:(int,int)) -> 'np.ndarray[np.int32]' : ...
    def normalize_minicolumn(self, conv_tensor: 'np.ndarray[np.float32]', norm: int) : ...
    def sparse_repeated_normalize(self, conv_tensor: 'np.ndarray[np.float32]', y: 'np.ndarray[np.int32]', norm: int) : ...
    def idx(self, input_pos: (int, int, int), output_pos: (int, int, int)) -> int : ...
    def sparse_dot(self, lhs_tensor: 'np.ndarray[np.int32]', rhs_conv_tensor: 'np.ndarray[np.float32]', dot_product_output: 'np.ndarray[np.float32]') -> 'np.ndarray[np.float32]' : ...
    def sparse_dot_repeated(self, lhs_tensor: 'np.ndarray[np.int32]', rhs_conv_tensor: 'np.ndarray[np.float32]', dot_product_output: 'np.ndarray[np.float32]') -> 'np.ndarray[np.float32]' : ...
    def sparse_mul_assign(self, conv_tensor: 'np.ndarray[np.float32]', epsilon: float, input: 'np.ndarray[np.int32]', output: 'np.ndarray[np.int32]') : ...
    def sparse_mul_assign_repeated(self, conv_tensor: 'np.ndarray[np.float32]', epsilon: float, input: 'np.ndarray[np.int32]', output: 'np.ndarray[np.int32]') : ...
    def sparse_increment(self, conv_tensor: 'np.ndarray[np.float32]', epsilon: float, input: 'np.ndarray[np.int32]', output: 'np.ndarray[np.int32]', biased: bool) : ...
    def sparse_increment_repeated(self, conv_tensor: 'np.ndarray[np.float32]', epsilon: float, input: 'np.ndarray[np.int32]', output: 'np.ndarray[np.int32]', biased: bool) : ...
    def update_u_as_expected_sk_minus_sj(self, epsilon: float, s: 'np.ndarray[np.float32]', y: 'np.ndarray[np.int32]', u_weights: 'np.ndarray[np.float32]') : ...
    def update_u_as_expected_sk_minus_sj_repeated(self, epsilon: float, s: 'np.ndarray[np.float32]', y: 'np.ndarray[np.int32]', u_weights: 'np.ndarray[np.float32]') : ...
    def compose(self, next: 'ConvShape') -> 'ConvShape' : ...
    @staticmethod
    def new_identity(shape: (int, int, int)) -> 'ConvShape' : ...
    @staticmethod
    def new_linear(input: int, output: int) -> 'ConvShape' : ...
    # def concat(layers: ['ConvShape']) -> 'ConvShape' : ...
    @staticmethod
    def new_in(input_shape: (int, int, int), out_channels: int, kernel: (int, int), stride: (int, int)) -> 'ConvShape' : ...
    @staticmethod
    def new_out(in_channels: int, output_shape: (int, int, int), kernel: (int, int), stride: (int, int)) -> 'ConvShape' : ...
    def set_stride(self, new_stride: (int, int)) : ...
    def repeat_minicolumn(self, weights: 'np.ndarray[np.float32]') -> 'np.ndarray[np.float32]' : ...
    def add_to_receptive_field_repeated(self, minicolumn_receptive_field: 'np.ndarray[np.float32]', x: 'np.ndarray[np.int32]', y: 'np.ndarray[np.int32]') : ...
    def __repr__(self) -> str : ...
    def __str__(self) -> str : ...

def version() -> int : ...
def batch_sparse(bools: 'np.ndarray[bool]') -> ('np.ndarray[np.int32]', 'np.ndarray[np.uint64]') : ...
def join_sparse(sparse: ['np.ndarray[np.int32]']) -> ('np.ndarray[np.int32]', 'np.ndarray[np.uint64]') : ...
def receptive_field(output_size:int, output_indices: 'np.ndarray[np.int32]', output_offsets:'np.ndarray[np.uint64]',
                    input_size:int, input_indices: 'np.ndarray[np.int32]', input_offsets:'np.ndarray[np.uint64]') -> 'np.ndarray[np.float32]': ...
def sparse_subtensor(indices: 'np.ndarray[np.int32]', tensor_shape:(int,int,int), from_pos:(int,int,int), to_pos:(int,int,int)) -> 'np.ndarray[np.int32]' : ...
def sparse_subtensor_reindexed( indices: 'np.ndarray[np.int32]', tensor_shape:(int,int,int), from_pos:(int,int,int), to_pos:(int,int,int)) -> 'np.ndarray[np.int32]': ...
def sparse(bools: 'np.ndarray[bool]') -> 'np.ndarray[np.int32]' : ...
def dense(indices: 'np.ndarray[np.uint]', length: int) -> 'np.ndarray[bool]' : ...
def dense_(indices: 'np.ndarray[np.uint]', output: 'np.ndarray[bool]') : ...
def sample(probabilities: 'np.ndarray[np.float32]') -> 'np.ndarray[bool]' : ...
def sample_of_cardinality(values: 'np.ndarray[np.float32]', cardinality: int, std_dev: float) -> 'np.ndarray[bool]' : ...
def rand_sparse_k(cardinality: int, from_inclusive: int, to_exclusive: int) -> 'np.ndarray[np.int32]' : ...
def rand_sparse_k_sorted(cardinality: int, from_inclusive: int, to_exclusive: int) -> 'np.ndarray[np.int32]' : ...
def rand_dense_k(cardinality: int, length: int) -> 'np.ndarray[bool]' : ...
def sparse_gt(dense: 'np.ndarray[np.float32]', threshold: float) -> 'np.ndarray[np.uint]' : ...
def sparse_top_k(dense: 'np.ndarray[np.float32]', k: int) -> 'np.ndarray[np.uint]' : ...
def dense_top_k(dense: 'np.ndarray[np.float32]', k: int) -> 'np.ndarray[bool]' : ...
def sparse_inner_product(sparse: 'np.ndarray[np.uint]', dense: 'np.ndarray[np.float32]') -> float : ...
def sparse_dot(sparse: 'np.ndarray[np.uint]', dense: 'np.ndarray[np.float32]') -> 'np.ndarray[np.float32]' : ...
def sparse_dot_t(dense: 'np.ndarray[np.float32]', sparse: 'np.ndarray[np.uint]') -> 'np.ndarray[np.float32]' : ...
def ordered_swta_v(v: 'np.ndarray[bool]', s: 'np.ndarray[np.float32]', si: 'np.ndarray[np.uint]') -> 'np.ndarray[bool]' : ...
def ordered_swta_u(u: 'np.ndarray[np.float32]', s: 'np.ndarray[np.float32]', si: 'np.ndarray[np.uint]') -> 'np.ndarray[bool]' : ...
def swta_v(v: 'np.ndarray[bool]', s: 'np.ndarray[np.float32]') -> 'np.ndarray[bool]' : ...
def swta_u(u: 'np.ndarray[np.float32]', s: 'np.ndarray[np.float32]') -> 'np.ndarray[bool]' : ...
def swta_u_(u: 'np.ndarray[np.float32]', s: 'np.ndarray[np.float32]', y: 'np.ndarray[np.uint8]') : ...
def swta_v_(v: 'np.ndarray[bool]', s: 'np.ndarray[np.float32]', y: 'np.ndarray[np.uint8]') : ...
def ordered_swta_u_(u: 'np.ndarray[np.float32]', s: 'np.ndarray[np.float32]', si: 'np.ndarray[np.uint]', y: 'np.ndarray[np.uint8]') : ...
def ordered_swta_v_(v: 'np.ndarray[bool]', s: 'np.ndarray[np.float32]', si: 'np.ndarray[np.uint]', y: 'np.ndarray[np.uint8]') : ...
def swta_u_conv_(u: 'np.ndarray[np.float32]', s: 'np.ndarray[np.float32]', y: 'np.ndarray[np.uint8]') : ...
def swta_v_conv_(v: 'np.ndarray[bool]', s: 'np.ndarray[np.float32]', y: 'np.ndarray[np.uint8]') : ...
def swta_u_repeated_conv_(u: 'np.ndarray[np.float32]', s: 'np.ndarray[np.float32]', y: 'np.ndarray[np.uint8]') : ...
def swta_v_repeated_conv_(v: 'np.ndarray[bool]', s: 'np.ndarray[np.float32]', y: 'np.ndarray[np.uint8]') : ...
def cyclic_group(n: int) -> 'np.ndarray[np.uint64]' : ...
def cyclic_monoid(n: int) -> 'np.ndarray[np.uint64]' : ...
def direct_product(a: 'np.ndarray[np.uint64]', b: 'np.ndarray[np.uint64]') -> 'np.ndarray[np.uint64]' : ...
def learn_uw(state_space: 'np.ndarray[np.uint64]', w: 'np.ndarray[np.float32]') -> ('np.ndarray[np.float32]', 'np.ndarray[np.float32]') : ...

class HwtaL2Layer:
    def __init__(self, cs: 'ConvShape', norm: int): ...
    def shape(self) -> 'ConvShape' : ...
    def n(self) -> int : ...
    def m(self) -> int : ...
    def run(self, x: 'np.ndarray[np.int32]') -> 'np.ndarray[np.int32]' : ...
    def batch_run(self,  indices: 'np.ndarray[np.int32]', offsets: 'np.ndarray[np.uint64]') -> ('np.ndarray[np.int32]','np.ndarray[np.uint64]') : ...
    def batch_run_conv(self,  indices: 'np.ndarray[np.int32]', offsets: 'np.ndarray[np.uint64]') -> ('np.ndarray[np.int32]','np.ndarray[np.uint64]') : ...
    def learn(self, x: 'np.ndarray[np.int32]', s: 'np.ndarray[np.float32]', y: 'np.ndarray[np.int32]') : ...
    def run_conv(self, x: 'np.ndarray[np.int32]') -> 'np.ndarray[np.int32]' : ...
    def train(self, x: 'np.ndarray[np.int32]') -> 'np.ndarray[np.int32]' : ...
    def learn_conv(self, x: 'np.ndarray[np.int32]', s: 'np.ndarray[np.float32]', y: 'np.ndarray[np.int32]') : ...
    def W(self) -> 'np.ndarray[np.float32]' : ...
    def r(self) -> 'np.ndarray[np.float32]' : ...
    def save(self, path:str) : ...

    @staticmethod
    def load(path:str) -> 'HwtaL2Layer' : ...

class SwtaLayer:
    def __init__(self, cs: 'ConvShape', norm: int): ...
    def shape(self) -> 'ConvShape' : ...
    def get_use_abs(self) -> bool : ...
    def set_use_abs(self, use_abs:bool): ...
    def get_use_cos_sim(self) -> bool : ...
    def set_use_cos_sim(self, cos_sim:bool): ...
    def get_conditional(self) -> bool : ...
    def set_conditional(self, conditional:bool): ...
    def W(self) -> 'np.ndarray[np.float32]' : ...
    def U(self) -> 'np.ndarray[np.float32]' : ...
    def n(self) -> int : ...
    def m(self) -> int : ...
    def run(self, x: 'np.ndarray[np.int32]') -> 'np.ndarray[np.int32]' : ...
    def learn(self, x: 'np.ndarray[np.int32]', s: 'np.ndarray[np.float32]', y: 'np.ndarray[np.int32]') : ...
    def run_conv(self, x: 'np.ndarray[np.int32]') -> 'np.ndarray[np.int32]' : ...
    def train(self, x: 'np.ndarray[np.int32]') -> 'np.ndarray[np.int32]' : ...
    def learn_conv(self, x: 'np.ndarray[np.int32]', s: 'np.ndarray[np.float32]', y: 'np.ndarray[np.int32]') : ...
    def save(self, path:str) : ...

    @staticmethod
    def load(path:str) -> 'SwtaLayer' : ...